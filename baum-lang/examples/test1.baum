module A = {
  x: 1 = 1
}
u = A.x
module X (x: 1) (y: 2) = {
  module p = {
  }
}
module C (x: A.u) {y: B} = {
  use A
  open X c d
  -- use import "mochi"
  -- local local open import "mochi"
  x = 1
  local {
    y = 2
  }
  module E = A x y z (a b) {x} {y z} A.p X.q
  local module D {q r: s t} (x: a) = {
    local open A
  }
}
k = let module X = {
    x = 1
  } in X.x
k = let module X = {
    x = 1
  } in Y.x
f = - 2
g = 1.2
u = Î£(x y: Nat, Nat, z: Q x y, P x y z)
v = Î£(x y: Nat, Nat, z: Q x y, P x y z,)

syntax 2.1< a + b = add a b
syntax 2.1< a - b = sub a b
syntax 2.2< a * b = mul a b
syntax 2.3> - a = neg a
syntax 2.4< a ! = fact a
syntax [ a | b ] = f a b
syntax [ a ? b ] = g a b

x = 1 + 2 * 3
y = 1 * 2 + 3
z = 1 + 2 +
z = 1 + [ 1 + 2 | 3 + 4 ] * 5
w = 1 + [ 1 + 2 ? 3 + 4 ] * 5
a = prim "mochi"
b = g Î»() x
b = g Î»(a) x
b = g Î»(a: b) x
b = Î£() Î»(a: b c, ) Î»{x: y} x
g = 1
k = let x = 1; y = 2 in t
"ðŸ–ðŸ½ðŸ–ðŸ½ðŸ–ðŸ½ðŸ–ðŸ½ðŸ–ðŸ½" a 1 2 a b 2 1 a b
g = k
ot = Î£{x: Î (Nat) Nat, y: Nat}
o = { x v: Nat = 1, y = 2 }
v = Ï€(1) x
v = Ï€(1 + 2) x -- fail
w = Ï€{prop} x
x = (x) + () + (x,y) + (x,y,z)
y = {}
z = x {y}
z = {y = 2}
z = x {y = 2}
y = {y = 1} + 2
y = {y} + 1 -- fail
u = 1 + 5
      
syntax [ a ] = block a
syntax 4> a â†’ b = Î (a) b
syntax 5> (a: e) â†’ b = Î (a: e) b
syntax 0> |a| b = Î»(a) b
k = |a| |b| a
k' = |a |b| b| a
j: (a: Nat) â†’ b = |a| 0
module A = {
  syntax 0> & a & = a
  syntax 0> # a @ = a
  syntax 0> ! a = a
  syntax 0> a ! = a
  syntax 4 a / b = add a b
}
pa' = & 0 &
pi' = 1 / 2
pa = A.! 0
pa = 0 A.!
pb = A.# 0 @
pa = A.& 0 &
pi = 1 A./ 2
syntax 1 po p = let x = 1 in po

v = x + 1